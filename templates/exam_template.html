<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Exam Question — {{ qid }}</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--canvas-w:900px; --canvas-h:650px; --diagram-target-w:600px;}
  body{font-family:Arial, Helvetica, sans-serif; margin:14px; color:#111;}
  h2{margin-bottom:10px;}
  .container{display:flex; gap:18px; align-items:flex-start;}
  @media(max-width:900px){ .container{flex-direction:column;} }
  .qpanel{ flex:0 0 48%; max-width:48%; min-width:260px; border:1px solid #ddd; padding:12px; box-sizing:border-box; background:#fafafa; overflow:hidden; }
  .qpanel h3{margin-top:0;}
  .qimg-wrap{ width:100%; height: calc(100vh - 220px); overflow:auto; border:1px dashed #eee; padding:8px; box-sizing:border-box; background:#fff; }
  .qimg-wrap img{display:block; width:100%; height:auto; object-fit:contain;}
  .dpanel{ flex:0 0 52%; max-width:52%; min-width:300px; box-sizing:border-box; text-align:center; }
  .canvas-wrapper{ width: var(--canvas-w); height: var(--canvas-h); max-width:100%; border:1px solid #bbb; margin: 0 auto; position: relative; background:#fff; touch-action: none; }
  #bgImg{ display:none; }
  .controls{ margin-top: 10px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
  .controls button, .controls input[type="range"], .controls select { padding:8px 10px; font-size:14px; }
  .small { font-size:13px; color:#444; margin-top:6px; text-align:center; }
  .answer-area{ margin-top:14px; }
  .answer-area textarea{ width:100%; min-height:110px; padding:10px; font-size:15px; box-sizing:border-box; }
  .meta-row{ display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center; }
  .meta-row input[type="text"]{ padding:8px; font-size:14px; width:220px; }
</style>
</head>
<body>
  <h2>Question {{ qid }}</h2>

  <div class="container">
    <div class="qpanel" aria-label="Question text">
      <h3>Question (Read-only)</h3>
      <div class="qimg-wrap" id="qimgWrap">
        <img id="questionImage" src="/question_file/{{ qid }}/{{ question_image }}" alt="Question image">
      </div>
      <div class="small">Scroll the question area if needed. Pinch/zoom the diagram to draw precisely.</div>
    </div>

    <div class="dpanel" aria-label="Drawing area">
      <h3>Diagram — draw in the box (you may draw outside the printed diagram)</h3>

      <div class="canvas-wrapper" id="canvasWrapper">
        <img id="bgImg" src="/question_file/{{ qid }}/{{ diagram_image }}" alt="Diagram to draw on">
        <canvas id="drawCanvas" width="900" height="650" style="display:block;"></canvas>
      </div>

      <div class="controls">
        <label>Pen size <input id="penSize" type="range" min="1" max="10" value="3"></label>
        <label>Tool
          <select id="tool">
            <option value="draw">Draw</option>
            <option value="erase">Eraser</option>
            <option value="line">Straight line</option>
          </select>
        </label>
        <button id="undoBtn">Undo</button>
        <button id="clearBtn">Clear</button>
        <button id="submitBtn">Submit</button>
      </div>

      <div class="small">Tip: use one finger for drawing. Use two fingers to pinch-zoom or to pan. On desktop use mouse wheel to zoom.</div>

      <div class="answer-area">
        <label><strong>Type your short answers here (write parts in order):</strong></label>
        <textarea id="answerText" placeholder="(a) ...  (b) ..."></textarea>

        <div class="meta-row">
          <input id="studentName" type="text" placeholder="Student name (required)">
          <div style="flex:1"></div>
          <span id="statusText" class="small"></span>
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------- Config ---------- */
const canvas = document.getElementById('drawCanvas');
const ctx = canvas.getContext('2d');
const bgImg = document.getElementById('bgImg');
const wrapper = document.getElementById('canvasWrapper');
const rectUpdate = () => canvas.getBoundingClientRect();
const CANVAS_W = canvas.width, CANVAS_H = canvas.height;
const DIAGRAM_TARGET_W = 600; // target diagram width inside canvas

/* ---------- Transform state ---------- */
let zoom = 1.0;            // zoom factor (1 = fitted scale)
let offsetX = 0, offsetY = 0; // panning offsets in canvas coordinate units
const MIN_ZOOM = 0.6, MAX_ZOOM = 3.0;

/* ---------- Drawing state ---------- */
let drawing = false;
let currentPath = null;
let paths = []; // stored as logical points (in canvas coordinates BEFORE transform)
const penSizeControl = document.getElementById('penSize');
const toolSel = document.getElementById('tool');

/* ---------- Helpers: map client pointer -> canvas coordinate (logical canvas units) ---------- */
function clientToCanvas(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  // x_canvas_raw = (client - rect.left) * (canvas.width / rect.width)
  const x_canvas_raw = (clientX - rect.left) * (canvas.width / rect.width);
  const y_canvas_raw = (clientY - rect.top) * (canvas.height / rect.height);
  // logical coordinate before transform:
  const x_logical = (x_canvas_raw - offsetX) / zoom;
  const y_logical = (y_canvas_raw - offsetY) / zoom;
  return { x: x_logical, y: y_logical };
}

/* ---------- Helpers: map logical -> screen (canvas pixel after transform) ---------- */
function logicalToScreen(pt) {
  return { x: pt.x * zoom + offsetX, y: pt.y * zoom + offsetY };
}

/* ---------- Pointer events for drawing ---------- */
function startStroke(e) {
  // only start drawing for single-touch or left mouse button
  if (e.pointerType === 'touch' && (e.touches && e.touches.length > 1)) return;
  if (e.buttons !== undefined && e.buttons !== 1 && e.pointerType !== 'touch') return;

  drawing = true;
  currentPath = { points: [], size: parseInt(penSizeControl.value,10), mode: toolSel.value || 'draw' };
  const p = getEventPoint(e);
  currentPath.points.push(p);
  redraw();
}
function moveStroke(e) {
  if (!drawing) return;
  const p = getEventPoint(e);
  currentPath.points.push(p);
  redraw();
}
function endStroke(e) {
  if (!drawing) return;
  drawing = false;
  if (currentPath && currentPath.points.length) {
    paths.push(currentPath);
    currentPath = null;
  }
}
function getEventPoint(e) {
  let clientX, clientY;
  if (e.touches && e.touches.length) {
    clientX = e.touches[0].clientX;
    clientY = e.touches[0].clientY;
  } else {
    clientX = (e.clientX !== undefined ? e.clientX : e.pageX);
    clientY = (e.clientY !== undefined ? e.clientY : e.pageY);
  }
  return clientToCanvas(clientX, clientY);
}

/* ---------- Render function ---------- */
function redraw() {
  // clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw white background
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw centered diagram scaled by zoom with offsets
  if (bgImg.complete) {
    const cfg = computeDiagramScaleAndOffsets(bgImg.naturalWidth, bgImg.naturalHeight, canvas.width, canvas.height);
    const drawW = cfg.drawW * zoom;
    const drawH = cfg.drawH * zoom;
    const left = cfg.left * zoom + offsetX;
    const top = cfg.top * zoom + offsetY;
    ctx.drawImage(bgImg, left, top, drawW, drawH);
  }

  // draw all saved paths (transform logical->screen)
  ctx.lineJoin = 'round'; ctx.lineCap = 'round';
  for (let p of paths) drawPath(ctx, p);
  if (currentPath) drawPath(ctx, currentPath);
}

/* draw single path (p.points are logical coords) */
function drawPath(ctxLocal, p) {
  if (!p || !p.points || p.points.length===0) return;
  if (p.mode === 'erase') {
    ctxLocal.globalCompositeOperation = 'destination-out';
    ctxLocal.strokeStyle = 'rgba(0,0,0,1)';
  } else {
    ctxLocal.globalCompositeOperation = 'source-over';
    ctxLocal.strokeStyle = '#000';
  }
  ctxLocal.lineWidth = p.size * zoom; // scale stroke on zoom for consistent visual
  ctxLocal.beginPath();
  let s = logicalToScreen(p.points[0]);
  ctxLocal.moveTo(s.x, s.y);
  for (let i=1;i<p.points.length;i++) {
    const prev = logicalToScreen(p.points[i-1]);
    const cur  = logicalToScreen(p.points[i]);
    const cx = (prev.x + cur.x)/2;
    const cy = (prev.y + cur.y)/2;
    ctxLocal.quadraticCurveTo(prev.x, prev.y, cx, cy);
  }
  ctxLocal.stroke();
  ctxLocal.globalCompositeOperation = 'source-over';
}

/* ---------- Compute diagram scale/offset for CENTERED placement (natural units) ---------- */
function computeDiagramScaleAndOffsets(imgW, imgH, canvasW, canvasH) {
  const targetW = Math.min(DIAGRAM_TARGET_W, canvasW - 80);
  const scale = targetW / imgW;
  const drawW = imgW * scale;
  const drawH = imgH * scale;
  const left = (canvasW - drawW)/2;
  const top  = (canvasH - drawH)/2;
  return { drawW, drawH, left, top };
}

/* ---------- Touch pinch/ pan handlers ---------- */
let isPointerDown = false;
let twoFinger = false;
let lastTouchDist = 0;
let lastTouchMid = null;
let lastPanClient = null;
let startZoom = null;
let startOffset = null;

function dist(t0, t1){ return Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY); }
function midPoint(t0,t1){ return { clientX: (t0.clientX+t1.clientX)/2, clientY:(t0.clientY+t1.clientY)/2 }; }

wrapper.addEventListener('touchstart', function(e){
  if (e.touches.length === 2) {
    twoFinger = true;
    lastTouchDist = dist(e.touches[0], e.touches[1]);
    lastTouchMid = midPoint(e.touches[0], e.touches[1]);
    startZoom = zoom;
    startOffset = { x: offsetX, y: offsetY };
  } else {
    twoFinger = false;
  }
}, {passive:false});

wrapper.addEventListener('touchmove', function(e){
  if (e.touches.length === 2) {
    e.preventDefault(); // prevent page scroll
    const newDist = dist(e.touches[0], e.touches[1]);
    const newMid = midPoint(e.touches[0], e.touches[1]);
    // compute client->canvas point for midpoint
    const rect = canvas.getBoundingClientRect();
    const midCanvasBefore = { x: (lastTouchMid.clientX - rect.left) * (canvas.width/rect.width),
                              y: (lastTouchMid.clientY - rect.top)  * (canvas.height/rect.height) };
    // logical point under midpoint
    const logicalMid = { x: (midCanvasBefore.x - startOffset.x)/startZoom, y: (midCanvasBefore.y - startOffset.y)/startZoom };

    // update zoom
    const ratio = newDist / lastTouchDist;
    let newZoom = startZoom * ratio;
    newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

    // compute new offset so that logicalMid maps to same screen (midpoint)
    const midCanvasNow = { x: (newMid.clientX - rect.left) * (canvas.width/rect.width),
                           y: (newMid.clientY - rect.top)  * (canvas.height/rect.height) };
    offsetX = midCanvasNow.x - logicalMid.x * newZoom;
    offsetY = midCanvasNow.y - logicalMid.y * newZoom;
    zoom = newZoom;
    redraw();
  } else if (e.touches.length === 1 && !drawing) {
    // single-finger pan when not drawing? (we avoid conflict: drawing is started by touch on canvas)
    // do nothing here; drawing touch events handle single-finger draw
  }
}, {passive:false});

wrapper.addEventListener('touchend', function(e){
  if (e.touches.length < 2) {
    twoFinger = false;
    lastTouchDist = 0;
    lastTouchMid = null;
    startZoom = null;
    startOffset = null;
  }
}, {passive:false});

/* ---------- Mouse wheel zoom (desktop) ---------- */
wrapper.addEventListener('wheel', function(e){
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const clientX = e.clientX, clientY = e.clientY;
  const canvasClientX = (clientX - rect.left) * (canvas.width/rect.width);
  const canvasClientY = (clientY - rect.top)  * (canvas.height/rect.height);

  const delta = -e.deltaY * 0.001;
  let newZoom = zoom * (1 + delta);
  newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

  // logical point under mouse
  const logicalX = (canvasClientX - offsetX) / zoom;
  const logicalY = (canvasClientY - offsetY) / zoom;

  // new offset so point remains under cursor
  offsetX = canvasClientX - logicalX * newZoom;
  offsetY = canvasClientY - logicalY * newZoom;
  zoom = newZoom;
  redraw();
}, {passive:false});

/* ---------- Undo / Clear ---------- */
document.getElementById('clearBtn').addEventListener('click', function(){
  if (!confirm('Clear all strokes?')) return;
  paths = []; currentPath = null; redraw();
});
document.getElementById('undoBtn').addEventListener('click', function(){ paths.pop(); redraw(); });

/* ---------- Pointer (mouse) drawing ---------- */
let mouseDown = false;
canvas.addEventListener('pointerdown', function(e){
  // only handle left button or touch
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  // If two-finger gesture in progress, ignore
  if (twoFinger) return;
  // start stroke
  mouseDown = true;
  drawing = true;
  currentPath = { points: [], size: parseInt(penSizeControl.value||penSizeControl.value,10) || 3, mode: toolSel.value || 'draw' };
  const p = clientToCanvas(e.clientX, e.clientY);
  currentPath.points.push(p);
  redraw();
  canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', function(e){
  if (!mouseDown) return;
  if (!drawing) return;
  const p = clientToCanvas(e.clientX, e.clientY);
  currentPath.points.push(p);
  redraw();
});
window.addEventListener('pointerup', function(e){
  if (mouseDown) {
    mouseDown = false;
    drawing = false;
    if (currentPath && currentPath.points.length) {
      paths.push(currentPath);
      currentPath = null;
    }
    redraw();
  }
});

/* ---------- Touch drawing fallback for some browsers ---------- */
canvas.addEventListener('touchstart', function(e){
  if (e.touches.length === 1 && !twoFinger) {
    // start drawing
    const t = e.touches[0];
    drawing = true;
    currentPath = { points: [], size: parseInt(penSizeControl.value,10), mode: toolSel.value || 'draw' };
    currentPath.points.push(clientToCanvas(t.clientX, t.clientY));
    redraw();
  }
}, {passive:false});
canvas.addEventListener('touchmove', function(e){
  if (drawing && e.touches.length === 1) {
    const t = e.touches[0];
    currentPath.points.push(clientToCanvas(t.clientX, t.clientY));
    e.preventDefault();
    redraw();
  }
}, {passive:false});
canvas.addEventListener('touchend', function(e){
  if (drawing) {
    drawing = false;
    if (currentPath && currentPath.points.length) paths.push(currentPath);
    currentPath = null;
    redraw();
  }
}, {passive:false});

/* ---------- Save merged image (background + strokes) ---------- */
document.getElementById('submitBtn').addEventListener('click', async function(){
  const studentName = document.getElementById('studentName').value.trim();
  if (!studentName) { alert('Please enter student name'); return; }

  const answerText = document.getElementById('answerText').value;

  // offscreen canvas (same logical size)
  const off = document.createElement('canvas');
  off.width = canvas.width;
  off.height = canvas.height;
  const octx = off.getContext('2d');

  // fill white
  octx.fillStyle = '#ffffff';
  octx.fillRect(0,0,off.width, off.height);

  // draw diagram at current zoom/offset
  if (bgImg.complete) {
    const cfg = computeDiagramScaleAndOffsets(bgImg.naturalWidth, bgImg.naturalHeight, off.width, off.height);
    const drawW = cfg.drawW * zoom;
    const drawH = cfg.drawH * zoom;
    const left = cfg.left * zoom + offsetX;
    const top = cfg.top * zoom + offsetY;
    octx.drawImage(bgImg, left, top, drawW, drawH);
  }

  // draw strokes (paths logical -> screen)
  octx.lineJoin = 'round'; octx.lineCap = 'round';
  for (let p of paths) {
    if (!p || !p.points || p.points.length===0) continue;
    if (p.mode === 'erase') {
      octx.globalCompositeOperation = 'destination-out';
      octx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      octx.globalCompositeOperation = 'source-over';
      octx.strokeStyle = '#000';
    }
    octx.lineWidth = p.size * zoom;
    octx.beginPath();
    const s0 = logicalToScreen(p.points[0]);
    octx.moveTo(s0.x, s0.y);
    for (let i=1;i<p.points.length;i++) {
      const prev = logicalToScreen(p.points[i-1]);
      const cur  = logicalToScreen(p.points[i]);
      const cx = (prev.x + cur.x)/2;
      const cy = (prev.y + cur.y)/2;
      octx.quadraticCurveTo(prev.x, prev.y, cx, cy);
    }
    octx.stroke();
    octx.globalCompositeOperation = 'source-over';
  }

  const dataURL = off.toDataURL('image/png');

  document.getElementById('statusText').textContent = "Saving...";
  try {
    const res = await fetch('/save_exam_answer', {
      method:'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        qid: "{{ qid }}",
        studentName: studentName,
        answerText: answerText,
        overlayImage: dataURL
      })
    });
    const j = await res.json();
    if (j.status === 'success') {
      document.getElementById('statusText').textContent = "Saved OK";
      alert('Saved successfully.');
    } else {
      document.getElementById('statusText').textContent = "Save error";
      alert('Save failed: ' + JSON.stringify(j));
    }
  } catch (err) {
    document.getElementById('statusText').textContent = "Network error";
    alert('Network error: ' + err.message);
  }
});

/* ---------- Redraw when bg loads ---------- */
bgImg.onload = function(){ 
  // initial fit: we want diagram to occupy DIAGRAM_TARGET_W inside canvas at zoom=1
  // compute initial cfg and adjust zoom so that diagram natural width -> target width (we already use computeDiagramScaleAndOffsets)
  // default zoom = 1 => compute centered placement; no change necessary
  redraw();
};

/* ---------- Initialize display ---------- */
redraw();
</script>
</body>
</html>
