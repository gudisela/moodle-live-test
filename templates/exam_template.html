<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Exam Question — {{ qid }}</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--canvas-w:900px; --canvas-h:650px; --diagram-target-w:600px;}
  body{font-family:Arial, Helvetica, sans-serif; margin:14px; color:#111;}
  h2{margin-bottom:10px;}
  .container{display:flex; gap:18px; align-items:flex-start;}
  @media(max-width:900px){ .container{flex-direction:column;} }
  .qpanel{ flex:0 0 48%; max-width:48%; min-width:260px; border:1px solid #ddd; padding:12px; box-sizing:border-box; background:#fafafa; overflow:hidden; }
  .qpanel h3{margin-top:0;}
  .qimg-wrap{ width:100%; height: calc(100vh - 220px); overflow:auto; border:1px dashed #eee; padding:8px; box-sizing:border-box; background:#fff; }
  .qimg-wrap img{display:block; width:100%; height:auto; object-fit:contain;}
  .dpanel{ flex:0 0 52%; max-width:52%; min-width:300px; box-sizing:border-box; text-align:center; }
  .canvas-wrapper{ width: var(--canvas-w); height: var(--canvas-h); max-width:100%; border:1px solid #bbb; margin: 0 auto; position: relative; background:#fff; touch-action: none; }
  #bgImg{ display:none; }
  .controls{ margin-top: 10px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
  .controls button, .controls input[type="range"], .controls select { padding:8px 10px; font-size:14px; }
  .small { font-size:13px; color:#444; margin-top:6px; text-align:center; }
  .answer-area{ margin-top:14px; }
  .answer-area textarea{ width:100%; min-height:110px; padding:10px; font-size:15px; box-sizing:border-box; }
  .meta-row{ display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center; }
  .meta-row input[type="text"]{ padding:8px; font-size:14px; width:220px; }
  .tool-active { outline: 2px solid #007bff; }
</style>
</head>
<body>
  <h2>Question {{ qid }}</h2>

  <div class="container">
    <div class="qpanel" aria-label="Question text">
      <h3>Question (Read-only)</h3>
      <div class="qimg-wrap" id="qimgWrap">
        <img id="questionImage" src="/question_file/{{ qid }}/{{ question_image }}" alt="Question image">
      </div>
      <div class="small">Scroll the question area if needed. Pinch/zoom the diagram to draw precisely.</div>
    </div>

    <div class="dpanel" aria-label="Drawing area">
      <h3>Diagram — draw in the box (you may draw outside the printed diagram)</h3>

      <div class="canvas-wrapper" id="canvasWrapper">
        <img id="bgImg" src="/question_file/{{ qid }}/{{ diagram_image }}" alt="Diagram to draw on">
        <canvas id="drawCanvas" width="900" height="650" style="display:block;"></canvas>
      </div>

      <div class="controls" role="toolbar" aria-label="Drawing tools">
        <label>Pen size <input id="penSize" type="range" min="1" max="10" value="3"></label>

        <button id="toolDraw" class="tool-btn tool-active" title="Free draw">Free</button>
        <button id="toolLine" class="tool-btn" title="Straight line">Line</button>
        <button id="toolErase" class="tool-btn" title="Eraser">Erase</button>

        <button id="undoBtn">Undo</button>
        <button id="clearBtn">Clear</button>
        <button id="submitBtn">Submit</button>
      </div>

      <div class="small">Tip: use one finger for drawing. Use two fingers to pinch-zoom or to pan. On desktop use mouse wheel to zoom. Line tool shows live straight-line preview.</div>

      <div class="answer-area">
        <label><strong>Type your short answers here (write parts in order):</strong></label>
        <textarea id="answerText" placeholder="(a) ...  (b) ..."></textarea>

        <div class="meta-row">
          <input id="studentName" type="text" placeholder="Student name (required)">
          <div style="flex:1"></div>
          <span id="statusText" class="small"></span>
        </div>
      </div>
    </div>
  </div>

<script>
/* ---------- Config and DOM ---------- */
const canvas = document.getElementById('drawCanvas');
const ctx = canvas.getContext('2d');
const bgImg = document.getElementById('bgImg');
const wrapper = document.getElementById('canvasWrapper');
const penSizeControl = document.getElementById('penSize');
const btnDraw = document.getElementById('toolDraw');
const btnLine = document.getElementById('toolLine');
const btnErase = document.getElementById('toolErase');

const CANVAS_W = canvas.width, CANVAS_H = canvas.height;
const DIAGRAM_TARGET_W = 600;

let tool = 'draw'; // 'draw' | 'line' | 'erase'
let zoom = 1.0, offsetX = 0, offsetY = 0;
const MIN_ZOOM = 0.6, MAX_ZOOM = 3.0;
let drawing = false;
let currentPath = null;   // { points: [ {x,y} logical], size, mode }
let paths = [];           // array of path objects

/* ---------- Utilities: coords ---------- */
function clientToCanvas(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x_canvas_raw = (clientX - rect.left) * (canvas.width / rect.width);
  const y_canvas_raw = (clientY - rect.top) * (canvas.height / rect.height);
  const x_logical = (x_canvas_raw - offsetX) / zoom;
  const y_logical = (y_canvas_raw - offsetY) / zoom;
  return { x: x_logical, y: y_logical };
}
function logicalToScreen(pt){
  return { x: pt.x * zoom + offsetX, y: pt.y * zoom + offsetY };
}

/* ---------- Tool button handlers (UI) ---------- */
function setTool(t){
  tool = t;
  [btnDraw, btnLine, btnErase].forEach(b => b.classList.remove('tool-active'));
  if (t === 'draw') btnDraw.classList.add('tool-active');
  else if (t === 'line') btnLine.classList.add('tool-active');
  else if (t === 'erase') btnErase.classList.add('tool-active');
}
btnDraw.onclick = ()=> setTool('draw');
btnLine.onclick = ()=> setTool('line');
btnErase.onclick = ()=> setTool('erase');

/* ---------- drawPath: handles straight lines & smooth curves ---------- */
function drawPath(ctxLocal, p){
  if (!p || !p.points || p.points.length===0) return;

  // Erase / normal stroke
  if (p.mode === 'erase') {
    ctxLocal.globalCompositeOperation = 'destination-out';
    ctxLocal.strokeStyle = 'rgba(0,0,0,1)';
  } else {
    ctxLocal.globalCompositeOperation = 'source-over';
    ctxLocal.strokeStyle = '#000';
  }

  ctxLocal.lineJoin = 'round';
  ctxLocal.lineCap = 'round';
  ctxLocal.lineWidth = p.size * zoom;

  ctxLocal.beginPath();

  if (p.mode === 'line') {
    // Draw exact straight line between first & last logical points
    const s0 = logicalToScreen(p.points[0]);
    const s1 = logicalToScreen(p.points[p.points.length - 1]);
    ctxLocal.moveTo(s0.x, s0.y);
    ctxLocal.lineTo(s1.x, s1.y);
  } else {
    // Smooth freehand (quadratic smoothing)
    const sStart = logicalToScreen(p.points[0]);
    ctxLocal.moveTo(sStart.x, sStart.y);
    for (let i = 1; i < p.points.length; i++){
      const prev = logicalToScreen(p.points[i-1]);
      const cur  = logicalToScreen(p.points[i]);
      const cx = (prev.x + cur.x)/2;
      const cy = (prev.y + cur.y)/2;
      ctxLocal.quadraticCurveTo(prev.x, prev.y, cx, cy);
    }
  }
  ctxLocal.stroke();
  ctxLocal.globalCompositeOperation = 'source-over';
}

/* ---------- redraw: background diagram + all paths + currentPath preview ---------- */
function redraw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw centered diagram at current zoom/offset
  if (bgImg.complete){
    const cfg = computeDiagramScaleAndOffsets(bgImg.naturalWidth, bgImg.naturalHeight, canvas.width, canvas.height);
    const drawW = cfg.drawW * zoom;
    const drawH = cfg.drawH * zoom;
    const left = cfg.left * zoom + offsetX;
    const top = cfg.top * zoom + offsetY;
    ctx.drawImage(bgImg, left, top, drawW, drawH);
  }

  // draw saved paths
  ctx.lineJoin = 'round'; ctx.lineCap = 'round';
  for (let p of paths) drawPath(ctx, p);
  // draw current path (preview)
  if (currentPath) drawPath(ctx, currentPath);
}

/* ---------- compute diagram centered size ---------- */
function computeDiagramScaleAndOffsets(imgW, imgH, canvasW, canvasH){
  const targetW = Math.min(DIAGRAM_TARGET_W, canvasW - 80);
  const scale = targetW / imgW;
  const drawW = imgW * scale;
  const drawH = imgH * scale;
  const left = (canvasW - drawW)/2;
  const top = (canvasH - drawH)/2;
  return { drawW, drawH, left, top };
}

/* ---------- Input handlers (pointer + touch) ---------- */
let twoFinger = false, lastTouchDist = 0, lastTouchMid = null, startZoom = null, startOffset = null;

function dist(t0,t1){ return Math.hypot(t1.clientX - t0.clientX, t1.clientY - t0.clientY); }
function midPoint(t0,t1){ return { clientX:(t0.clientX+t1.clientX)/2, clientY:(t0.clientY+t1.clientY)/2 }; }

// two-finger pinch start
wrapper.addEventListener('touchstart', function(e){
  if (e.touches.length === 2){
    twoFinger = true;
    lastTouchDist = dist(e.touches[0], e.touches[1]);
    lastTouchMid = midPoint(e.touches[0], e.touches[1]);
    startZoom = zoom;
    startOffset = { x: offsetX, y: offsetY };
  } else {
    twoFinger = false;
  }
}, {passive:false});

wrapper.addEventListener('touchmove', function(e){
  if (e.touches.length === 2){
    e.preventDefault();
    const newDist = dist(e.touches[0], e.touches[1]);
    const newMid = midPoint(e.touches[0], e.touches[1]);

    const rect = canvas.getBoundingClientRect();
    const midCanvasBefore = { x:(lastTouchMid.clientX-rect.left)*(canvas.width/rect.width), y:(lastTouchMid.clientY-rect.top)*(canvas.height/rect.height) };
    const logicalMid = { x:(midCanvasBefore.x - startOffset.x)/startZoom, y:(midCanvasBefore.y - startOffset.y)/startZoom };

    const ratio = newDist / lastTouchDist;
    let newZoom = startZoom * ratio;
    newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

    const midCanvasNow = { x:(newMid.clientX-rect.left)*(canvas.width/rect.width), y:(newMid.clientY-rect.top)*(canvas.height/rect.height) };
    offsetX = midCanvasNow.x - logicalMid.x * newZoom;
    offsetY = midCanvasNow.y - logicalMid.y * newZoom;
    zoom = newZoom;
    redraw();
  }
}, {passive:false});

wrapper.addEventListener('touchend', function(e){
  if (e.touches.length < 2){
    twoFinger = false;
    lastTouchDist = 0;
    lastTouchMid = null;
    startZoom = null;
    startOffset = null;
  }
}, {passive:false});

// wheel zoom (desktop)
wrapper.addEventListener('wheel', function(e){
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const canvasClientX = (e.clientX - rect.left) * (canvas.width/rect.width);
  const canvasClientY = (e.clientY - rect.top) * (canvas.height/rect.height);
  const delta = -e.deltaY * 0.001;
  let newZoom = zoom * (1 + delta);
  newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));

  const logicalX = (canvasClientX - offsetX) / zoom;
  const logicalY = (canvasClientY - offsetY) / zoom;

  offsetX = canvasClientX - logicalX * newZoom;
  offsetY = canvasClientY - logicalY * newZoom;
  zoom = newZoom;
  redraw();
}, {passive:false});

/* ---------- Drawing: pointer events ---------- */
let isPointerDown = false;
canvas.addEventListener('pointerdown', function(e){
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  if (twoFinger) return;
  isPointerDown = true;
  drawing = true;
  const p = clientToCanvas(e.clientX, e.clientY);
  currentPath = { points: [p], size: parseInt(penSizeControl.value,10), mode: tool };
  redraw();
  canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointermove', function(e){
  if (!isPointerDown || !drawing) return;
  const p = clientToCanvas(e.clientX, e.clientY);
  currentPath.points.push(p);
  // For line mode we don't need many points; preview draws straight between first and last
  redraw();
});
window.addEventListener('pointerup', function(e){
  if (!isPointerDown) return;
  isPointerDown = false;
  drawing = false;
  if (currentPath && currentPath.points.length){
    // Trim line points to first and last for exact straight line
    if (currentPath.mode === 'line' && currentPath.points.length > 1){
      currentPath.points = [ currentPath.points[0], currentPath.points[currentPath.points.length - 1] ];
    }
    paths.push(currentPath);
    currentPath = null;
    redraw();
  }
});

// touch fallback for some browsers
canvas.addEventListener('touchstart', function(e){
  if (e.touches.length === 1 && !twoFinger){
    const t = e.touches[0];
    drawing = true;
    const p = clientToCanvas(t.clientX, t.clientY);
    currentPath = { points: [p], size: parseInt(penSizeControl.value,10), mode: tool };
    redraw();
  }
}, {passive:false});
canvas.addEventListener('touchmove', function(e){
  if (drawing && e.touches.length === 1){
    const t = e.touches[0];
    currentPath.points.push(clientToCanvas(t.clientX, t.clientY));
    e.preventDefault();
    redraw();
  }
}, {passive:false});
canvas.addEventListener('touchend', function(e){
  if (drawing){
    drawing = false;
    if (currentPath && currentPath.points.length){
      if (currentPath.mode === 'line' && currentPath.points.length > 1){
        currentPath.points = [ currentPath.points[0], currentPath.points[currentPath.points.length - 1] ];
      }
      paths.push(currentPath);
      currentPath = null;
      redraw();
    }
  }
}, {passive:false});

/* ---------- Undo / Clear ---------- */
document.getElementById('clearBtn').addEventListener('click', function(){
  if (!confirm('Clear all strokes?')) return;
  paths = []; currentPath = null; redraw();
});
document.getElementById('undoBtn').addEventListener('click', function(){
  paths.pop(); redraw();
});

/* ---------- Save merged image (background + strokes) ---------- */
document.getElementById('submitBtn').addEventListener('click', async function(){
  const studentName = document.getElementById('studentName').value.trim();
  if (!studentName) { alert('Please enter student name'); return; }
  const answerText = document.getElementById('answerText').value;

  const off = document.createElement('canvas');
  off.width = canvas.width;
  off.height = canvas.height;
  const octx = off.getContext('2d');

  // white bg
  octx.fillStyle = '#ffffff';
  octx.fillRect(0,0,off.width,off.height);

  if (bgImg.complete){
    const cfg = computeDiagramScaleAndOffsets(bgImg.naturalWidth, bgImg.naturalHeight, off.width, off.height);
    const drawW = cfg.drawW * zoom;
    const drawH = cfg.drawH * zoom;
    const left = cfg.left * zoom + offsetX;
    const top = cfg.top * zoom + offsetY;
    octx.drawImage(bgImg, left, top, drawW, drawH);
  }

  octx.lineJoin = 'round'; octx.lineCap = 'round';
  for (let p of paths){
    if (!p || !p.points || p.points.length===0) continue;
    if (p.mode === 'erase'){
      octx.globalCompositeOperation = 'destination-out';
      octx.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      octx.globalCompositeOperation = 'source-over';
      octx.strokeStyle = '#000';
    }
    octx.lineWidth = p.size * zoom;
    octx.beginPath();
    if (p.mode === 'line'){
      const s0 = logicalToScreen(p.points[0]);
      const s1 = logicalToScreen(p.points[p.points.length - 1]);
      octx.moveTo(s0.x, s0.y);
      octx.lineTo(s1.x, s1.y);
    } else {
      const s0 = logicalToScreen(p.points[0]);
      octx.moveTo(s0.x, s0.y);
      for (let i=1;i<p.points.length;i++){
        const prev = logicalToScreen(p.points[i-1]);
        const cur  = logicalToScreen(p.points[i]);
        const cx = (prev.x + cur.x)/2;
        const cy = (prev.y + cur.y)/2;
        octx.quadraticCurveTo(prev.x, prev.y, cx, cy);
      }
    }
    octx.stroke();
    octx.globalCompositeOperation = 'source-over';
  }

  const dataURL = off.toDataURL('image/png');

  document.getElementById('statusText').textContent = "Saving...";
  try {
    const res = await fetch('/save_exam_answer', {
      method:'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        qid: "{{ qid }}",
        studentName: studentName,
        answerText: answerText,
        overlayImage: dataURL
      })
    });
    const j = await res.json();
    if (j.status === 'success'){
      document.getElementById('statusText').textContent = "Saved OK";
      alert('Saved successfully.');
    } else {
      document.getElementById('statusText').textContent = "Save error";
      alert('Save failed: ' + JSON.stringify(j));
    }
  } catch (err){
    document.getElementById('statusText').textContent = "Network error";
    alert('Network error: ' + err.message);
  }
});

/* ---------- Redraw when bg loads ---------- */
bgImg.onload = function(){ redraw(); };

/* ---------- Init ---------- */
redraw();
</script>
</body>
</html>
