<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Exam: {{ exam.title }} — Question {{ qindex }}/{{ total }}</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--canvas-w:900px; --canvas-h:650px; --diagram-target-w:600px;}
  body{font-family:Arial, Helvetica, sans-serif; margin:14px; color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;}
  .container{display:flex; gap:18px; align-items:flex-start; margin-top:12px;}
  @media(max-width:900px){ .container{flex-direction:column;} }
  .qpanel{ flex:0 0 48%; max-width:48%; min-width:260px; border:1px solid #ddd; padding:12px; box-sizing:border-box; background:#fafafa; overflow:hidden; }
  .qimg-wrap{ width:100%; height: calc(100vh - 220px); overflow:auto; border:1px dashed #eee; padding:8px; box-sizing:border-box; background:#fff; }
  .dpanel{ flex:0 0 52%; max-width:52%; min-width:300px; box-sizing:border-box; text-align:center; }
  .canvas-wrapper{ width: var(--canvas-w); height: var(--canvas-h); max-width:100%; border:1px solid #bbb; margin: 0 auto; position: relative; background:#fff; touch-action: none; }
  .controls{ margin-top: 10px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }
  .controls button, .controls input[type="range"]{ padding:8px 10px; font-size:14px; }
  .meta-row{ display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; align-items:center; }
  .meta-row input[type="text"]{ padding:8px; font-size:14px; width:220px; }
  footer{ margin-top:14px; display:flex; justify-content:space-between; align-items:center; gap:10px; }
  .nav-btn { padding:10px 14px; font-size:15px; }
</style>
</head>
<body>
<header>
  <div>
    <h2>{{ exam.title }}</h2>
    <div>Question {{ qindex }} of {{ total }} — marks: {{ question.marks or '' }}</div>
  </div>
  <div>
    <small>Teacher: {{ exam.created_by }}</small><br>
    <small>Exam ID: {{ exam_id }}</small>
  </div>
</header>

<div class="container">
  <div class="qpanel">
    <h3>Question (Read-only)</h3>
    <div class="qimg-wrap">
      <img src="/exam_file/{{ exam_id }}/{{ question.question_image }}" style="width:100%;height:auto" alt="Question image">
    </div>
  </div>

  <div class="dpanel">
    <h3>Diagram — annotate</h3>
    <div class="canvas-wrapper" id="canvasWrapper">
      <img id="bgImg" src="/exam_file/{{ exam_id }}/{{ question.diagram_image }}" alt="diagram" style="display:none;">
      <canvas id="drawCanvas" width="900" height="650"></canvas>
    </div>

    <div class="controls">
      <label>Pen size <input id="penSize" type="range" min="1" max="10" value="3"></label>
      <button id="btnFree">Free</button>
      <button id="btnLine">Line</button>
      <button id="btnErase">Erase</button>
      <button id="undoBtn">Undo</button>
      <button id="clearBtn">Clear</button>
    </div>

    <div style="margin-top:12px;">
      <label><strong>Your answer:</strong></label>
      <textarea id="answerText" style="width:100%; min-height:120px"></textarea>
      <div class="meta-row">
        <input id="studentName" type="text" placeholder="Student name (required)">
        <div style="flex:1"></div>
        <span id="statusText"></span>
      </div>
    </div>
  </div>
</div>

<footer>
  <div>
    <button id="prevBtn" class="nav-btn" {{ 'disabled' if qindex<=1 else '' }}>◀ Previous</button>
    <button id="nextBtn" class="nav-btn" {{ 'disabled' if qindex>=total else '' }}>Next ▶</button>
  </div>
  <div>
    <button id="saveBtn" class="nav-btn">Save (now)</button>
    <button id="submitExam" class="nav-btn">Finish & Submit Exam</button>
  </div>
</footer>

<script>
/* ---------- Basic vars ---------- */
const examId = "{{ exam_id }}";
const qindex = {{ qindex }};
const totalQ = {{ total }};
const qid = "{{ question.qid }}";

/* ---------- Canvas/drawing — simple adaptation of your working code ---------- */
const canvas = document.getElementById('drawCanvas');
const ctx = canvas.getContext('2d');
const bgImg = document.getElementById('bgImg');
const wrapper = document.getElementById('canvasWrapper');
const penSizeControl = document.getElementById('penSize');

let tool = 'draw';
let zoom = 1.0, offsetX = 0, offsetY = 0;
let drawing = false;
let currentPath = null;
let paths = [];

document.getElementById('btnFree').onclick = ()=> { tool='draw'; };
document.getElementById('btnLine').onclick = ()=> { tool='line'; };
document.getElementById('btnErase').onclick = ()=> { tool='erase'; };

function clientToCanvas(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x_canvas_raw = (clientX - rect.left) * (canvas.width / rect.width);
  const y_canvas_raw = (clientY - rect.top) * (canvas.height / rect.height);
  const x_logical = (x_canvas_raw - offsetX) / zoom;
  const y_logical = (y_canvas_raw - offsetY) / zoom;
  return { x: x_logical, y: y_logical };
}
function logicalToScreen(pt){
  return { x: pt.x * zoom + offsetX, y: pt.y * zoom + offsetY };
}

function drawPathLocal(ctxLocal, p){
  if (!p || !p.points || p.points.length===0) return;
  if (p.mode === 'erase') { ctxLocal.globalCompositeOperation='destination-out'; ctxLocal.strokeStyle='rgba(0,0,0,1)'; }
  else { ctxLocal.globalCompositeOperation='source-over'; ctxLocal.strokeStyle='#000'; }
  ctxLocal.lineJoin='round'; ctxLocal.lineCap='round'; ctxLocal.lineWidth = p.size * zoom;
  ctxLocal.beginPath();
  if (p.mode === 'line'){
    const s0 = logicalToScreen(p.points[0]);
    const s1 = logicalToScreen(p.points[p.points.length-1]);
    ctxLocal.moveTo(s0.x,s0.y);
    ctxLocal.lineTo(s1.x,s1.y);
  } else {
    const s0 = logicalToScreen(p.points[0]);
    ctxLocal.moveTo(s0.x,s0.y);
    for (let i=1;i<p.points.length;i++){
      const prev = logicalToScreen(p.points[i-1]);
      const cur  = logicalToScreen(p.points[i]);
      const cx = (prev.x+cur.x)/2; const cy = (prev.y+cur.y)/2;
      ctxLocal.quadraticCurveTo(prev.x, prev.y, cx, cy);
    }
  }
  ctxLocal.stroke(); ctxLocal.globalCompositeOperation='source-over';
}

function redrawAll(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);
  if (bgImg.complete){
    const cfg = computeDiagramScaleAndOffsets(bgImg.naturalWidth, bgImg.naturalHeight, canvas.width, canvas.height);
    const drawW = cfg.drawW * zoom; const drawH = cfg.drawH * zoom;
    const left = cfg.left * zoom + offsetX; const top = cfg.top * zoom + offsetY;
    ctx.drawImage(bgImg, left, top, drawW, drawH);
  }
  for (let p of paths) drawPathLocal(ctx, p);
  if (currentPath) drawPathLocal(ctx, currentPath);
}

function computeDiagramScaleAndOffsets(imgW,imgH,canvasW,canvasH){
  const targetW = Math.min({{ DIAGRAM_TARGET_W if false else 600 }}, canvasW - 80);
  const scale = targetW / imgW;
  const drawW = imgW * scale; const drawH = imgH * scale;
  const left = (canvasW - drawW)/2; const top = (canvasH - drawH)/2;
  return { drawW, drawH, left, top };
}

/* pointer events */
let isPointerDown=false;
canvas.addEventListener('pointerdown', function(e){
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  isPointerDown = true;
  drawing = true;
  const p = clientToCanvas(e.clientX, e.clientY);
  currentPath = { points: [p], size: parseInt(penSizeControl.value,10), mode: tool };
  canvas.setPointerCapture(e.pointerId);
  redrawAll();
});
canvas.addEventListener('pointermove', function(e){
  if (!isPointerDown || !drawing) return;
  const p = clientToCanvas(e.clientX, e.clientY);
  currentPath.points.push(p);
  redrawAll();
});
window.addEventListener('pointerup', function(e){
  if (!isPointerDown) return;
  isPointerDown=false; drawing=false;
  if (currentPath && currentPath.points.length){
    if (currentPath.mode === 'line' && currentPath.points.length > 1){
      currentPath.points = [ currentPath.points[0], currentPath.points[currentPath.points.length - 1] ];
    }
    paths.push(currentPath);
    currentPath=null;
    redrawAll();
  }
});

/* undo/clear */
document.getElementById('undoBtn').addEventListener('click', ()=>{ paths.pop(); redrawAll(); });
document.getElementById('clearBtn').addEventListener('click', ()=>{ if(confirm('Clear all?')){ paths=[]; redrawAll(); } });

/* zoom/pan: simple wheel zoom; pinch/advanced code can be added later */
wrapper.addEventListener('wheel', function(e){ e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const canvasClientX = (e.clientX-rect.left)*(canvas.width/rect.width);
  const canvasClientY = (e.clientY-rect.top)*(canvas.height/rect.height);
  const delta = -e.deltaY * 0.001;
  let newZoom = zoom * (1 + delta);
  newZoom = Math.max(0.6, Math.min(3.0, newZoom));
  const logicalX = (canvasClientX - offsetX) / zoom;
  const logicalY = (canvasClientY - offsetY) / zoom;
  offsetX = canvasClientX - logicalX * newZoom;
  offsetY = canvasClientY - logicalY * newZoom;
  zoom = newZoom; redrawAll();
}, {passive:false});

/* ---------- Save (autosave + manual) ---------- */
async function saveCurrentAnswer(saveNow=false){
  const student = document.getElementById('studentName').value.trim();
  if (!student) { document.getElementById('statusText').textContent = "Enter name"; return; }

  // merge background + strokes into offscreen canvas (same size)
  const off = document.createElement('canvas'); off.width = canvas.width; off.height = canvas.height;
  const octx = off.getContext('2d');
  octx.fillStyle='#fff'; octx.fillRect(0,0,off.width,off.height);

  if (bgImg.complete){
    const cfg = computeDiagramScaleAndOffsets(bgImg.naturalWidth, bgImg.naturalHeight, off.width, off.height);
    const drawW = cfg.drawW * zoom; const drawH = cfg.drawH * zoom;
    const left = cfg.left * zoom + offsetX; const top = cfg.top * zoom + offsetY;
    octx.drawImage(bgImg, left, top, drawW, drawH);
  }

  octx.lineJoin='round'; octx.lineCap='round';
  for (let p of paths){
    if (!p || !p.points || p.points.length===0) continue;
    if (p.mode === 'erase'){ octx.globalCompositeOperation='destination-out'; octx.strokeStyle='rgba(0,0,0,1)'; }
    else { octx.globalCompositeOperation='source-over'; octx.strokeStyle='#000'; }
    octx.lineWidth = p.size * zoom;
    octx.beginPath();
    if (p.mode === 'line'){
      const s0 = logicalToScreen(p.points[0]);
      const s1 = logicalToScreen(p.points[p.points.length-1]);
      octx.moveTo(s0.x, s0.y);
      octx.lineTo(s1.x, s1.y);
    } else {
      const s0 = logicalToScreen(p.points[0]); octx.moveTo(s0.x, s0.y);
      for (let i=1;i<p.points.length;i++){
        const prev = logicalToScreen(p.points[i-1]); const cur = logicalToScreen(p.points[i]);
        const cx = (prev.x+cur.x)/2; const cy=(prev.y+cur.y)/2;
        octx.quadraticCurveTo(prev.x, prev.y, cx, cy);
      }
    }
    octx.stroke(); octx.globalCompositeOperation='source-over';
  }

  const dataURL = off.toDataURL('image/png');

  document.getElementById('statusText').textContent = "Saving...";
  try {
    const res = await fetch('/exam/autosave', {
      method:'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({
        exam_id: examId,
        qindex: qindex,
        studentName: student,
        answerText: document.getElementById('answerText').value,
        overlayImage: dataURL
      })
    });
    const j = await res.json();
    if (j.status === 'success'){
      document.getElementById('statusText').textContent = "Saved " + new Date().toLocaleTimeString();
      if (saveNow) alert('Saved');
    } else {
      document.getElementById('statusText').textContent = "Save failed";
    }
  } catch (err) {
    document.getElementById('statusText').textContent = "Network error";
  }
}

/* Autosave when clicking next/prev and periodic autosave */
document.getElementById('nextBtn').addEventListener('click', async function(){
  await saveCurrentAnswer(true);
  if (qindex < totalQ) {
    window.location.href = `/exam/${examId}/q/${qindex+1}`;
  }
});
document.getElementById('prevBtn').addEventListener('click', async function(){
  await saveCurrentAnswer(true);
  if (qindex > 1) {
    window.location.href = `/exam/${examId}/q/${qindex-1}`;
  }
});
document.getElementById('saveBtn').addEventListener('click', ()=> saveCurrentAnswer(true));
window.addEventListener('beforeunload', function(e){
  // synchronous save is hard; we attempt navigator.sendBeacon
  const student = document.getElementById('studentName').value.trim();
  if (!student) return;
  const payload = {
    exam_id: examId, qindex: qindex, studentName: student,
    answerText: document.getElementById('answerText').value,
    overlayImage: canvas.toDataURL('image/png')
  };
  try {
    navigator.sendBeacon('/exam/autosave', JSON.stringify(payload));
  } catch(e){}
});

/* finish & submit exam */
document.getElementById('submitExam').addEventListener('click', async function(){
  await saveCurrentAnswer(true);
  const student = document.getElementById('studentName').value.trim();
  if (!student) { alert('Enter name'); return; }
  if (!confirm('Submit exam? You will not be able to change answers after this.')) return;
  try {
    const res = await fetch('/exam/submit', {
      method:'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ exam_id: examId, studentName: student })
    });
    const j = await res.json();
    if (j.status === 'success'){
      alert('Submitted. Thank you.');
      window.location.href = '/';
    } else {
      alert('Submit failed: ' + (j.message || ''));
    }
  } catch (err) {
    alert('Network error: ' + err.message);
  }
});

/* load: draw background then initial redraw */
bgImg.onload = function(){ redrawAll(); };
redrawAll();
</script>
</body>
</html>
